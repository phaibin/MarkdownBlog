---
layout: post
title: IM Integration With XMPP4r
date: 2009-06-23 16:06
categories:
- RoR
tags: []
published: true
comments: true
---
<p><p>原文：<a title="http://www.rubyfleebie.com/im-integration-with-xmpp4r" href="http://www.rubyfleebie.com/im-integration-with-xmpp4r">http://www.rubyfleebie.com/im-integration-with-xmpp4r</a></p> <p>你们可能注意到我在一个叫做TimmyOnTime的项目上工作过。这是一个允许你只通过IM就可以追踪你的时间的产品。它是怎么工作的？代码在哪里？好吧，我不会告诉你的…但是我会帮你从XMPP4r开始（XMPP For Ruby）。</p> <p>这将会是一篇多部分的文章。依我的风格不会略过XMPP直接开始讨论XMPP4R的。第一篇文章只会讨论XMPP…</p> <h2><strong>XMPP是什么？</strong></h2> <p>e<strong>X</strong>tensible <strong>M</strong>essaging and <strong>P</strong>resence <strong>P</strong>rotocol（又叫Jabber），是一种在两个实体之间交换信息的协议。信息以XML格式来记录。</p> <h2><strong>分布式</strong></h2> <p>不像MSN或者AIM是私有协议/技术，没有人拥有Jabber。你并不会像登录MSN一样登录到确定的Jabber服务器。当你用一个Jabber客户端工具比如Pidgin、Google Talk（技术上来讲GTalk并不是一个Jabber客户端，不过我们不深究了）或者Gajim，你会登录到某一个Jabber服务器。你甚至可以架设自己的Jabber服务器。这不会产生什么问题，因为这些服务器可以互相通讯（但是并不强迫这么做…私有Jabber服务器也非常普遍）。服务器之间通讯是Jabber架构的主要优点之一。</p> <p>比如我正在用Pidgin，我的Jabber帐号位于<a href="http://www.jabjab.de">www.jabjab.de</a>（公共jabber服务器之一），我的JID（Jabber Identifier）的形式为：<a href="mailto:frank@jabjab.de/home">frank@jabjab.de/home</a>。</p> <h2><strong>JID</strong></h2> <p>JID的第一部分是“frank”，这标识出一个节点，或者说一个人。第二部分是“jabjab.de”，标识出为了发送信息给frank需要呼叫的服务器。最后一部分是“/home”，标识出资源（RESOURCE）。资源就像是多部分标识符。Frank可能同时登录两个Pidgin的实例（一个在家，一个在公司），所以会导致不同的JID：<a href="mailto:&ldquo;frank@jabjab.de/home">“frank@jabjab.de/home</a>”和<a href="mailto:&ldquo;frank@jabjab.de/work">“frank@jabjab.de/work</a>”。</p> <h2><strong>XML信息：流（Stream）和节（Stanzas）</strong></h2> <p>Jabber的信息以XML格式编码。一个流（Stream）是一个在客户端和服务器之间交换信息的容器（比如在pidgin和jabjab.de之间）。它只是一个简单的叫做“stream”的XML元素，用&lt;stream&gt;和&lt;/stream&gt;包围起来。在stream元素内部，客户端和服务器都可以交换其他种类的XML消息（叫做stanzas）。当其中一方送出闭合的&lt;/stream&gt;之后通讯就终结了。例如，如果我关掉Pidgin，Pidgin就会送出&lt;/stream&gt;给jabjab.de，然后会话（session）就结束了。</p> <p>很重要的一点是：sream并不存在于用户A和用户B之间…它只存在于你的客户端（比如Pidgin）和你的Jabber帐号位于的服务器之间（比如jabjab.de）。</p> <p>Stanzas是在stream元素中发出的特殊种类的XML消息。最常见的三种stanzas是：</p> <ol> <li>Message  </li><li>Presence  </li><li>IQ</li></ol> <p>一个message节被用来从一个用户A（<a href="mailto:john@someserver.com/home">john@someserver.com/home</a>）发送消息到用户B（<a href="mailto:frank@someserver.com/home">frank@someserver.com/home</a>）。形式可能是：</p> <blockquote> <p>&lt;stream&gt;<br />&lt;message to=’frank@someserver.com/home’&gt;<br />&lt;body&gt;Frank… are you there?&lt;/body&gt;<br />&lt;/message&gt;<br />…<br />…<br />&lt;/stream&gt;&lt;!—如果会话还在继续可能并没有关闭的sream元素，一切都是实时发生的—&gt;</p></blockquote> <p>然我们思考一下当一条信息在两个不同服务器之间的实体间传送的时候都发生了什么。用户A通过他的IM客户端发送了一条消息。这条message节会被送往用户A的服务器someserver.com。someserver.com看到这条消息打算发往someotherserver.com的用户B，于是它发送到那里。someotherserver.com将最终发送这条message节给用户B（假设用户B和someotherserver.com已经通过一个stream元素建立了连接）。</p> <p>一个presence节会在用户状态改变的时候发出（空闲，离线，在线，忙碌，等等）。</p> <p>IQ（Info/Query）节是更加通用的消息。可以用来让用户A获取用户B的信息，而这些信息不能通过发送一条message或者presence节来获取。比如，如果用户A选择查看用户B的信息，一条IQ节就会被发往用户B，而用户B会用另一条IQ节包含用户A请求的信息来答复用户A。</p> <p>这就是这篇文章的第一部分，下一部分我们开始讨论XMPP4r。关于XMPP我还有一点没有提到，就是安全连接（SASL或者TLS）。下一部分也会讨论这个。</p></p>
